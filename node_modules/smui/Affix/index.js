var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".vue-affix {\n    position: relative;\n}\n\n.affix {\n    position: fixed;\n}\n\n.affix-bottom {\n    position: relative;\n}")
;(function(){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    props: {
        relativeElementSelector: {
            type: String,
            required: true
        },

        offset: {
            type: Object,
            default: function _default() {
                return {
                    top: 40,
                    bottom: 40
                };
            }
        },

        enabled: {
            type: Boolean,
            default: true
        },

        scrollAffix: {
            type: Boolean,
            default: false
        }
    },

    computed: {
        relativeElement: function relativeElement() {
            return document.querySelector(this.relativeElementSelector);
        }
    },

    data: function data() {
        return {
            affixHeight: null,
            affixBottomPos: null,
            affixRect: null,
            relativeElmBottomPos: null,
            relativeElmOffsetTop: null,
            topPadding: null,
            lastState: null,
            currentState: null,
            currentScrollAffix: null,
            distanceFromTop: window.scrollY,
            lastDistanceFromTop: window.scrollY,
            scrollingUp: null,
            scrollingDown: null
        };
    },


    methods: {
        setDynamicVariables: function setDynamicVariables() {
            this.distanceFromTop = window.scrollY;
            this.affixRect = this.$el.getBoundingClientRect();
            this.affixHeight = this.$el.offsetHeight;
            this.affixBottomPos = this.distanceFromTop + this.affixRect.bottom;
            this.screenBottomPos = this.distanceFromTop + window.innerHeight;
            this.relativeElmBottomPos = this.distanceFromTop + this.relativeElement.getBoundingClientRect().bottom;
            this.relativeElmOffsetTop = this.getOffsetTop(this.relativeElement);
        },
        onScroll: function onScroll() {
            if (!this.enabled) {
                this.removeClasses();
                return;
            }

            this.setDynamicVariables();

            if (this.affixHeight + this.offset.top >= this.relativeElement.offsetHeight) {
                return;
            } else {
                this.handleAffix();
            }
        },
        handleAffix: function handleAffix() {
            if (this.scrollAffix && this.affixHeight > window.innerHeight) {
                this.setScrollingDirection();

                if (this.currentScrollAffix == 'scrollaffix-top') {
                    if (this.distanceFromTop + this.offset.top >= this.affixInitialTop) {
                        this.setScrollAffixScrolling();
                    }
                }

                if (this.scrollingDown && this.currentScrollAffix == 'scrollaffix-scrolling') {
                    if (this.screenBottomPos >= this.affixBottomPos + this.offset.bottom && this.screenBottomPos < this.relativeElmBottomPos) {
                        this.setScrollAffixDown();
                    }
                }

                if (this.scrollingUp && this.currentScrollAffix == 'scrollaffix-scrolling') {
                    if (this.distanceFromTop + this.offset.top + this.topPadding < this.affixRect.top + this.distanceFromTop) {
                        this.setScrollAffixUp();
                    }
                }

                if (this.scrollingDown && this.currentScrollAffix == 'scrollaffix-down') {
                    if (this.screenBottomPos >= this.relativeElmBottomPos + this.offset.bottom) {
                        this.setScrollAffixBottom();
                    }
                }

                if (this.currentScrollAffix == 'scrollaffix-bottom' && this.screenBottomPos < this.relativeElmBottomPos) {
                    this.setScrollAffixScrolling();
                }

                if (this.scrollingUp && this.currentScrollAffix == 'scrollaffix-down' || this.scrollingDown && this.currentScrollAffix == 'scrollaffix-up') {
                    this.setScrollAffixScrolling();
                }

                if (this.scrollingUp && this.currentScrollAffix == 'scrollaffix-up' && this.distanceFromTop < this.relativeElmOffsetTop - this.offset.top) {
                    this.setScrollAffixTop();
                }

                this.lastScrollAffixState = this.currentScrollAffix;
                this.lastDistanceFromTop = this.distanceFromTop;
                return;
            }

            if (this.distanceFromTop < this.relativeElmOffsetTop - this.offset.top) {
                this.setAffixTop();
            }
            if (this.distanceFromTop >= this.relativeElmOffsetTop - this.offset.top && this.relativeElmBottomPos - this.offset.bottom >= this.distanceFromTop + this.topPadding + this.affixHeight + this.offset.top) {
                this.setAffix();
            }
            if (this.relativeElmBottomPos - this.offset.bottom < this.distanceFromTop + this.topPadding + this.affixHeight + this.offset.top) {
                this.setAffixBottom();
            }

            this.lastState = this.currentState;
        },
        initScrollAffix: function initScrollAffix() {
            if (this.distanceFromTop < this.affixInitialTop - this.offset.top) {
                this.setScrollAffixTop();
            } else if (this.screenBottomPos >= this.affixBottomPos + this.offset.bottom && this.screenBottomPos < this.relativeElmBottomPos) {
                this.setScrollAffixDown();
            } else if (this.screenBottomPos >= this.relativeElmBottomPos) {
                this.setScrollAffixBottom();
            } else {
                this.setScrollAffixScrolling();
            }
        },
        setScrollAffixScrolling: function setScrollAffixScrolling() {
            this.currentScrollAffix = 'scrollaffix-scrolling';
            this.$el.style.top = this.affixRect.top + this.distanceFromTop - this.affixInitialTop + 'px';
            this.$el.style.bottom = 'auto';
            this.removeClasses();
            this.emitEvent();
        },
        setScrollAffixUp: function setScrollAffixUp() {
            this.currentScrollAffix = 'scrollaffix-up';

            if (this.currentScrollAffix != this.lastState) {
                this.$el.style.top = this.topPadding + this.offset.top + 'px';
                this.$el.style.bottom = 'auto';
                this.removeClasses();
                this.emitEvent();
                this.$el.classList.add('affix');
            }
        },
        setScrollAffixDown: function setScrollAffixDown() {
            this.currentScrollAffix = 'scrollaffix-down';

            if (this.currentScrollAffix != this.lastState) {
                this.$el.style.bottom = this.offset.bottom + 'px';
                this.$el.style.top = 'auto';
                this.removeClasses();
                this.emitEvent();
                this.$el.classList.add('affix');
            }
        },
        setScrollAffixTop: function setScrollAffixTop() {
            this.currentScrollAffix = 'scrollaffix-top';
            this.$el.style.top = 0;
            this.$el.style.bottom = 'auto';
            this.removeClasses();
            this.emitEvent();
        },
        setScrollAffixBottom: function setScrollAffixBottom() {
            this.currentScrollAffix = 'scrollaffix-bottom';
            this.$el.style.top = this.relativeElmBottomPos - this.affixInitialTop - this.affixHeight + 'px';
            this.$el.style.bottom = 'auto';
            this.removeClasses();
            this.emitEvent();
        },
        setScrollingDirection: function setScrollingDirection() {
            if (this.distanceFromTop > this.lastDistanceFromTop) {
                this.scrollingDown = true;
                this.scrollingUp = false;
            } else {
                this.scrollingUp = true;
                this.scrollingDown = false;
            }
        },
        setAffixTop: function setAffixTop() {
            this.currentState = 'affix-top';

            if (this.currentState != this.lastState) {
                this.emitEvent();
                this.removeClasses();
                this.$el.classList.remove('affix');
                this.$el.classList.add('affix-top');
                this.$el.style.top = null;
            }
        },
        setAffix: function setAffix() {
            this.currentState = 'affix';
            this.$el.style.top = this.topPadding + this.offset.top + 'px';

            if (this.currentState != this.lastState) {
                this.emitEvent();
                this.removeClasses();
                this.$el.classList.add('affix');
            }
        },
        setAffixBottom: function setAffixBottom() {
            this.currentState = 'affix-bottom';
            this.$el.style.top = this.relativeElement.offsetHeight - this.affixHeight - this.offset.bottom - this.topPadding + 'px';

            if (this.currentState != this.lastState) {
                this.emitEvent();
                this.removeClasses();
                this.$el.classList.add('affix-bottom');
            }
        },
        removeClasses: function removeClasses() {
            this.$el.classList.remove('affix-top');
            this.$el.classList.remove('affix');
            this.$el.classList.remove('affix-bottom');
        },
        emitEvent: function emitEvent() {
            if (this.scrollAffix && this.lastScrollAffixState) {
                this.$emit(this.currentScrollAffix.replace('-', ''));
            }

            if (this.lastState) {
                this.$emit(this.currentState.replace('-', ''));
            }
        },
        getOffsetTop: function getOffsetTop(element) {
            var yPosition = 0;

            while (element) {
                yPosition += element.offsetTop;
                element = element.offsetParent;
            }

            return yPosition;
        }
    },

    mounted: function mounted() {
        this.$el.classList.add('vue-affix');
        this.affixInitialTop = this.getOffsetTop(this.$el);
        this.topPadding = this.affixInitialTop - this.getOffsetTop(this.relativeElement);

        this.setDynamicVariables();

        if (this.scrollAffix) this.initScrollAffix();

        this.onScroll();
        document.addEventListener('scroll', this.onScroll);
    },
    beforeDestroy: function beforeDestroy() {
        document.removeEventListener('scroll', this.onScroll);
    }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_vm._t("default")],2)}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require("vueify/node_modules/vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-086f203b", __vue__options__)
  } else {
    hotAPI.reload("data-v-086f203b", __vue__options__)
  }
})()}