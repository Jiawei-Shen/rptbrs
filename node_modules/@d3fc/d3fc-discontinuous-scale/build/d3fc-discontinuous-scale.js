(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-scale'), require('@d3fc/d3fc-rebind'), require('d3-time')) :
    typeof define === 'function' && define.amd ? define(['exports', 'd3-scale', '@d3fc/d3fc-rebind', 'd3-time'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.fc = global.fc || {}, global.d3, global.fc, global.d3));
}(this, (function (exports, d3Scale, d3fcRebind, d3Time) { 'use strict';

    function identity () {
      var identity = {};

      identity.distance = function (start, end) {
        return end - start;
      };

      identity.offset = function (start, offset) {
        return start instanceof Date ? new Date(start.getTime() + offset) : start + offset;
      };

      identity.clampUp = function (d) {
        return d;
      };

      identity.clampDown = function (d) {
        return d;
      };

      identity.copy = function () {
        return identity;
      };

      return identity;
    }

    function tickFilter(ticks, discontinuityProvider) {
      var discontinuousTicks = ticks.map(discontinuityProvider.clampUp);

      if (discontinuousTicks.length !== new Set(discontinuousTicks.map(function (d) {
        return d === null || d === void 0 ? void 0 : d.valueOf();
      })).size) {
        console.warn('There are multiple ticks that fall within a discontinuity, which has led to them being rendered on top of each other. Consider using scale.ticks to explicitly specify the ticks for the scale.');
      }

      return discontinuousTicks;
    }

    function discontinuous(adaptedScale) {
      var _this = this;

      if (!arguments.length) {
        adaptedScale = d3Scale.scaleIdentity();
      }

      var discontinuityProvider = identity();

      var scale = function scale(value) {
        var domain = adaptedScale.domain();
        var range = adaptedScale.range(); // The discontinuityProvider is responsible for determine the distance between two points
        // along a scale that has discontinuities (i.e. sections that have been removed).
        // the scale for the given point 'x' is calculated as the ratio of the discontinuous distance
        // over the domain of this axis, versus the discontinuous distance to 'x'

        var totalDomainDistance = discontinuityProvider.distance(domain[0], domain[1]);
        var distanceToX = discontinuityProvider.distance(domain[0], value);
        var ratioToX = distanceToX / totalDomainDistance;
        var scaledByRange = ratioToX * (range[1] - range[0]) + range[0];
        return scaledByRange;
      };

      scale.invert = function (x) {
        var domain = adaptedScale.domain();
        var range = adaptedScale.range();
        var ratioToX = (x - range[0]) / (range[1] - range[0]);
        var totalDomainDistance = discontinuityProvider.distance(domain[0], domain[1]);
        var distanceToX = ratioToX * totalDomainDistance;
        return discontinuityProvider.offset(domain[0], distanceToX);
      };

      scale.domain = function () {
        if (!arguments.length) {
          return adaptedScale.domain();
        }

        var newDomain = arguments.length <= 0 ? undefined : arguments[0]; // clamp the upper and lower domain values to ensure they
        // do not fall within a discontinuity

        var domainLower = discontinuityProvider.clampUp(newDomain[0]);
        var domainUpper = discontinuityProvider.clampDown(newDomain[1]);
        adaptedScale.domain([domainLower, domainUpper]);
        return scale;
      };

      scale.nice = function () {
        adaptedScale.nice();
        var domain = adaptedScale.domain();
        var domainLower = discontinuityProvider.clampUp(domain[0]);
        var domainUpper = discontinuityProvider.clampDown(domain[1]);
        adaptedScale.domain([domainLower, domainUpper]);
        return scale;
      };

      scale.ticks = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var ticks = adaptedScale.ticks.apply(_this, args);
        return tickFilter(ticks, discontinuityProvider);
      };

      scale.copy = function () {
        return discontinuous(adaptedScale.copy()).discontinuityProvider(discontinuityProvider.copy());
      };

      scale.discontinuityProvider = function () {
        if (!arguments.length) {
          return discontinuityProvider;
        }

        discontinuityProvider = arguments.length <= 0 ? undefined : arguments[0];
        return scale;
      };

      d3fcRebind.rebindAll(scale, adaptedScale, d3fcRebind.include('range', 'rangeRound', 'interpolate', 'clamp', 'tickFormat'));
      return scale;
    }

    var base = function base(dayAccessor, intervalDay, intervalSaturday, intervalMonday) {
      // the indices returned by dayAccessor(date)
      var day = {
        sunday: 0,
        monday: 1,
        saturday: 6
      };
      var millisPerDay = 24 * 3600 * 1000;
      var millisPerWorkWeek = millisPerDay * 5;
      var millisPerWeek = millisPerDay * 7;
      var skipWeekends = {};

      var isWeekend = function isWeekend(date) {
        return dayAccessor(date) === 0 || dayAccessor(date) === 6;
      };

      skipWeekends.clampDown = function (date) {
        if (date && isWeekend(date)) {
          // round the date up to midnight
          var newDate = intervalDay.ceil(date); // then subtract the required number of days

          if (dayAccessor(newDate) === day.sunday) {
            return intervalDay.offset(newDate, -1);
          } else if (dayAccessor(newDate) === day.monday) {
            return intervalDay.offset(newDate, -2);
          } else {
            return newDate;
          }
        } else {
          return date;
        }
      };

      skipWeekends.clampUp = function (date) {
        if (date && isWeekend(date)) {
          // round the date down to midnight
          var newDate = intervalDay.floor(date); // then add the required number of days

          if (dayAccessor(newDate) === day.saturday) {
            return intervalDay.offset(newDate, 2);
          } else if (dayAccessor(newDate) === day.sunday) {
            return intervalDay.offset(newDate, 1);
          } else {
            return newDate;
          }
        } else {
          return date;
        }
      }; // returns the number of included milliseconds (i.e. those which do not fall)
      // within discontinuities, along this scale


      skipWeekends.distance = function (startDate, endDate) {
        startDate = skipWeekends.clampUp(startDate);
        endDate = skipWeekends.clampDown(endDate); // move the start date to the end of week boundary

        var offsetStart = intervalSaturday.ceil(startDate);

        if (endDate < offsetStart) {
          return endDate.getTime() - startDate.getTime();
        }

        var msAdded = offsetStart.getTime() - startDate.getTime(); // move the end date to the end of week boundary

        var offsetEnd = intervalSaturday.ceil(endDate);
        var msRemoved = offsetEnd.getTime() - endDate.getTime(); // determine how many weeks there are between these two dates
        // round to account for DST transitions

        var weeks = Math.round((offsetEnd.getTime() - offsetStart.getTime()) / millisPerWeek);
        return weeks * millisPerWorkWeek + msAdded - msRemoved;
      };

      skipWeekends.offset = function (startDate, ms) {
        var date = isWeekend(startDate) ? skipWeekends.clampUp(startDate) : startDate;

        if (ms === 0) {
          return date;
        }

        var isNegativeOffset = ms < 0;
        var isPositiveOffset = ms > 0;
        var remainingms = ms; // move to the end of week boundary for a postive offset or to the start of a week for a negative offset

        var weekBoundary = isNegativeOffset ? intervalMonday.floor(date) : intervalSaturday.ceil(date);
        remainingms -= weekBoundary.getTime() - date.getTime(); // if the distance to the boundary is greater than the number of ms
        // simply add the ms to the current date

        if (isNegativeOffset && remainingms > 0 || isPositiveOffset && remainingms < 0) {
          return new Date(date.getTime() + ms);
        } // skip the weekend for a positive offset


        date = isNegativeOffset ? weekBoundary : intervalDay.offset(weekBoundary, 2); // add all of the complete weeks to the date

        var completeWeeks = Math.floor(remainingms / millisPerWorkWeek);
        date = intervalDay.offset(date, completeWeeks * 7);
        remainingms -= completeWeeks * millisPerWorkWeek; // add the remaining time

        date = new Date(date.getTime() + remainingms);
        return date;
      };

      skipWeekends.copy = function () {
        return skipWeekends;
      };

      return skipWeekends;
    };
    var skipWeekends = (function () {
      return base(function (date) {
        return date.getDay();
      }, d3Time.timeDay, d3Time.timeSaturday, d3Time.timeMonday);
    });

    var skipUtcWeekends = (function () {
      return base(function (date) {
        return date.getUTCDay();
      }, d3Time.utcDay, d3Time.utcSaturday, d3Time.utcMonday);
    });

    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it;

      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;

          var F = function () {};

          return {
            s: F,
            n: function () {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function (e) {
              throw e;
            },
            f: F
          };
        }

        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      var normalCompletion = true,
          didErr = false,
          err;
      return {
        s: function () {
          it = o[Symbol.iterator]();
        },
        n: function () {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function (e) {
          didErr = true;
          err = e;
        },
        f: function () {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        }
      };
    }

    var provider = function provider() {
      for (var _len = arguments.length, ranges = new Array(_len), _key = 0; _key < _len; _key++) {
        ranges[_key] = arguments[_key];
      }

      var inRange = function inRange(number, range) {
        return number > range[0] && number < range[1];
      };

      var surroundsRange = function surroundsRange(inner, outer) {
        return inner[0] >= outer[0] && inner[1] <= outer[1];
      };

      var identity = {};

      identity.distance = function (start, end) {
        start = identity.clampUp(start);
        end = identity.clampDown(end);
        var surroundedRanges = ranges.filter(function (r) {
          return surroundsRange(r, [start, end]);
        });
        var rangeSizes = surroundedRanges.map(function (r) {
          return r[1] - r[0];
        });
        return end - start - rangeSizes.reduce(function (total, current) {
          return total + current;
        }, 0);
      };

      var add = function add(value, offset) {
        return value instanceof Date ? new Date(value.getTime() + offset) : value + offset;
      };

      identity.offset = function (location, offset) {
        if (offset > 0) {
          var _ret = function () {
            var currentLocation = identity.clampUp(location);
            var offsetRemaining = offset;

            while (offsetRemaining > 0) {
              var futureRanges = ranges.filter(function (r) {
                return r[0] > currentLocation;
              }).sort(function (a, b) {
                return a[0] - b[0];
              });

              if (futureRanges.length) {
                var nextRange = futureRanges[0];
                var delta = nextRange[0] - currentLocation;

                if (delta > offsetRemaining) {
                  currentLocation = add(currentLocation, offsetRemaining);
                  offsetRemaining = 0;
                } else {
                  currentLocation = nextRange[1];
                  offsetRemaining -= delta;
                }
              } else {
                currentLocation = add(currentLocation, offsetRemaining);
                offsetRemaining = 0;
              }
            }

            return {
              v: currentLocation
            };
          }();

          if (_typeof(_ret) === "object") return _ret.v;
        } else {
          var _ret2 = function () {
            var currentLocation = identity.clampDown(location);
            var offsetRemaining = offset;

            while (offsetRemaining < 0) {
              var futureRanges = ranges.filter(function (r) {
                return r[1] < currentLocation;
              }).sort(function (a, b) {
                return b[0] - a[0];
              });

              if (futureRanges.length) {
                var nextRange = futureRanges[0];
                var delta = nextRange[1] - currentLocation;

                if (delta < offsetRemaining) {
                  currentLocation = add(currentLocation, offsetRemaining);
                  offsetRemaining = 0;
                } else {
                  currentLocation = nextRange[0];
                  offsetRemaining -= delta;
                }
              } else {
                currentLocation = add(currentLocation, offsetRemaining);
                offsetRemaining = 0;
              }
            }

            return {
              v: currentLocation
            };
          }();

          if (_typeof(_ret2) === "object") return _ret2.v;
        }
      };

      identity.clampUp = function (d) {
        return ranges.reduce(function (value, range) {
          return inRange(value, range) ? range[1] : value;
        }, d);
      };

      identity.clampDown = function (d) {
        return ranges.reduce(function (value, range) {
          return inRange(value, range) ? range[0] : value;
        }, d);
      };

      identity.copy = function () {
        return identity;
      };

      return identity;
    };

    var millisPerDay = 24 * 3600 * 1000;
    var dayBoundary = "00:00:00.000";
    var SOD = 'SOD';
    var EOD = 'EOD';

    /**
     * Attempts to parse and format a time string into a fixed lenght string 'hh:mm:ss.fff'
     * @param {string} timeString - string representation of time 'hh:mm:ss.fff' e.g. '09:30' or '00:00:00.000'
     * @returns {int[]} array of parsed time components [hh, mm, ss, ms] or throws.
     */

    function standardiseTimeString(timeString) {
      if (arguments.length !== 1 || typeof timeString !== 'string') {
        throw 'Expected single argument of type string';
      }

      var isPositiveIntegerUpTo = function isPositiveIntegerUpTo(toCheck, upperBound) {
        if (!Number.isInteger(toCheck)) return false;
        return toCheck >= 0 && toCheck <= upperBound;
      };

      var result = [0, 0, 0, 0];
      var time_components = timeString.split(":");

      if (time_components.length < 2 || time_components.length > 3) {
        throw 'Expected an argument wiht 2 or 3 colon delimited parts.';
      }

      result[0] = isPositiveIntegerUpTo(parseInt(time_components[0], 10), 23) ? parseInt(time_components[0], 10) : function () {
        throw "'Hours' component must be an int between 0 and 23, but was '".concat(time_components[0], "'");
      }();
      result[1] = isPositiveIntegerUpTo(parseInt(time_components[1], 10), 59) ? parseInt(time_components[1], 10) : function () {
        throw "'Minutes' component must be an int between 0 and 59, but was '".concat(time_components[1], "'");
      }();

      if (time_components.length === 3) {
        var ms_components = time_components[2].split(".").map(function (x) {
          return parseInt(x, 10);
        });
        result[2] = isPositiveIntegerUpTo(ms_components[0], 59) ? ms_components[0] : function () {
          throw "'Seconds' component must be an int between 0 and 59, but was '".concat(ms_components[0], "'");
        }();

        if (ms_components.length === 2) {
          result[3] = isPositiveIntegerUpTo(ms_components[1], 999) ? ms_components[1] : function () {
            throw "'Miliseconds' component must be an int between 0 and 999, but was '".concat(ms_components[1], "'");
          }();
        }
      }

      return "".concat(result[0].toString(10).padStart(2, '0'), ":").concat(result[1].toString(10).padStart(2, '0'), ":").concat(result[2].toString(10).padStart(2, '0'), ".").concat(result[3].toString(10).padStart(3, '0'));
    }
    /**
     * @typedef { Object } nonTradingTimeRange
     * @property { string } startTime - Start time string with fixed format 'hh:mm:ss.fff'
     * @property { string } endTime - End time string with fixed format 'hh:mm:ss.fff'
     * @property { int } lenghtInMs - Absolute length in MS i.e. only valid on non-Daylight saving boundaries
     */

    /**
     * Represents a single continous Non-Trading time interval within a single day. You must denote day boundries as:
     * SOD - start of day 
     * EOD  - end of day
     * @constructor
     * @param { string[] } timeRangeTuple - Time range as a tuple of time strings e.g. ["07:45", "08:30"), ["SOD", "08:30:20") or ["19:00:45.500", "EOD").
     * @param { import('./dateTimeUtility').DateTimeUtility } dateTimeUtility
     * @returns { nonTradingTimeRange }
     */

    function nonTradingTimeRange(timeRangeTuple, dateTimeUtility) {
      if (arguments.length != 2 || !Array.isArray(timeRangeTuple) || timeRangeTuple.length !== 2 || typeof timeRangeTuple[0] !== 'string' || typeof timeRangeTuple[1] !== 'string') {
        throw "Expected argument is a single string[] of length 2.";
      }

      if (timeRangeTuple[0] === SOD) {
        timeRangeTuple[0] = dayBoundary;
      }

      if (timeRangeTuple[1] === EOD) {
        timeRangeTuple[1] = dayBoundary;
      }

      var startTime = standardiseTimeString(timeRangeTuple[0]);
      var endTime = standardiseTimeString(timeRangeTuple[1]);

      if (endTime !== dayBoundary && startTime > endTime) {
        throw "Time range start time '".concat(startTime, "' must be before end time '").concat(endTime, "' or both must equal ").concat(dayBoundary);
      }

      var lenghtInMs = dateTimeUtility.setTime(new Date(endTime === dayBoundary ? millisPerDay : 0), endTime) - dateTimeUtility.setTime(new Date(0), startTime);
      var instance = {
        startTime: startTime,
        endTime: endTime,
        lenghtInMs: lenghtInMs
      };
      /**
       * Returns if given date's time portion is within this discontinuity time range instance
       * @param { Date } date - date
       * @returns { boolean }
       */

      instance.isInRange = function (date) {
        var time = dateTimeUtility.getTimeString(date);

        if (instance.startTime <= time && (instance.endTime === dayBoundary || instance.endTime > time)) {
          return true;
        }

        return false;
      };

      return instance;
    }

    /**
     * Represents a Trading day
     * @param { string[][] } rawDiscontinuityTimeRanges - Array of time range tuples e.g. [["07:45", "08:30"), ["19:00:45.500", "EOD")]
     * @param { import('./dateTimeUtility').DateTimeUtility } dateTimeUtility
     */

    var tradingDay = function tradingDay(rawDiscontinuityTimeRanges, dateTimeUtility) {
      var nonTradingTimeRanges = rawDiscontinuityTimeRanges.map(function (rawRange) {
        return nonTradingTimeRange(rawRange, dateTimeUtility);
      }).sort(function (a, b) {
        return a.startTime < b.startTime ? -1 : a.startTime > b.startTime ? 1 : 0;
      });
      var totalTradingTimeInMiliseconds = millisPerDay - nonTradingTimeRanges.reduce(function (total, range) {
        return total + range.lenghtInMs;
      }, 0);

      var totalTradingMillisecondsBetween = function totalTradingMillisecondsBetween(intervalStart, intervalEnd) {
        if (intervalStart.getTime() === intervalEnd.getTime()) {
          return 0;
        } // ensure arguments are on the same day or intervalEnd is the next day boundary


        if (dateTimeUtility.dayInterval(intervalStart).getTime() !== dateTimeUtility.dayInterval(intervalEnd).getTime() && dateTimeUtility.getStartOfNextDay(intervalStart).getTime() !== intervalEnd.getTime()) {
          throw "tradingDay.totalTradingMillisecondsBetween arguments must be on the same day or intervalEnd must be the start of the next day instead: intervalStart: '".concat(intervalStart, "'; intervalEnd: '").concat(intervalEnd, "'");
        }

        var total = 0;
        var relevantDiscontinuityRanges = nonTradingTimeRanges.filter(function (range) {
          return range.endTime === dayBoundary || dateTimeUtility.setTime(intervalStart, range.endTime) >= intervalStart;
        });

        var _iterator = _createForOfIteratorHelper(relevantDiscontinuityRanges),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var nonTradingRange = _step.value;
            var nonTradingStart = dateTimeUtility.setTime(intervalStart, nonTradingRange.startTime);
            var nonTradingEnd = nonTradingRange.endTime === dayBoundary ? dateTimeUtility.getStartOfNextDay(intervalStart) : dateTimeUtility.setTime(intervalStart, nonTradingRange.endTime); // both intervalStart and intervalEnd are before the start of this non-trading range

            if (intervalStart < nonTradingStart && intervalEnd < nonTradingStart) {
              return total + dateTimeUtility.msInterval.count(intervalStart, intervalEnd);
            } // intervalStart is before the start of this non-trading time range


            if (intervalStart < nonTradingStart) {
              total += dateTimeUtility.msInterval.count(intervalStart, nonTradingStart);
            } // interval ends within non-trading range


            if (intervalEnd < nonTradingEnd) {
              return total;
            } // set interval start to the end of non-trading range


            intervalStart = nonTradingEnd;
          } // add any interval time still left after iterating through all non-trading ranges

        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return total + dateTimeUtility.msInterval.count(intervalStart, intervalEnd);
      };

      var offset = function offset(date, ms) {
        if (ms === 0) {
          return [date, ms];
        }

        var offsetDate = dateTimeUtility.msInterval.offset(date, ms);
        var nonTradingRanges = ms > 0 ? nonTradingTimeRanges.filter(function (range) {
          return dateTimeUtility.setTime(date, range.startTime) >= date;
        }) : nonTradingTimeRanges.filter(function (range) {
          return dateTimeUtility.setTime(date, range.startTime) < date;
        }).reverse();

        if (nonTradingRanges.length === 0) {
          return [dateTimeUtility.msInterval.offset(date, ms), 0];
        }

        if (ms > 0) {
          var _iterator2 = _createForOfIteratorHelper(nonTradingRanges),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var nonTradingRange = _step2.value;
              var rangeStart = dateTimeUtility.setTime(date, nonTradingRange.startTime);

              if (rangeStart <= offsetDate) {
                // offsetDate is within non-trading range
                ms -= dateTimeUtility.msInterval.count(date, rangeStart);
                date = nonTradingRange.endTime === dayBoundary ? dateTimeUtility.getStartOfNextDay(date) : dateTimeUtility.setTime(date, nonTradingRange.endTime);
                offsetDate = dateTimeUtility.msInterval.offset(date, ms);
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          ms -= dateTimeUtility.msInterval.count(date, offsetDate);
        } else {
          var _iterator3 = _createForOfIteratorHelper(nonTradingRanges),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _nonTradingRange = _step3.value;
              var endTime = _nonTradingRange.endTime === dayBoundary ? dateTimeUtility.getStartOfNextDay(date) : dateTimeUtility.setTime(date, _nonTradingRange.endTime);

              if (offsetDate < endTime) {
                // offsetDate is within non-trading range
                ms += dateTimeUtility.msInterval.count(endTime, date) + 1;
                date = dateTimeUtility.msInterval.offset(dateTimeUtility.setTime(date, _nonTradingRange.startTime), -1);
                offsetDate = dateTimeUtility.msInterval.offset(date, ms);
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          ms += dateTimeUtility.msInterval.count(offsetDate, date);
        }

        if (ms !== 0) {
          throw 'tradingDay.offset was called with an offset that spans more than a day';
        }

        return [offsetDate, ms];
      };

      return {
        totalTradingTimeInMiliseconds: totalTradingTimeInMiliseconds,
        nonTradingTimeRanges: nonTradingTimeRanges,
        totalTradingMillisecondsBetween: totalTradingMillisecondsBetween,
        offset: offset
      };
    };

    /**
     * Object that helps with working with time strings and dates
     * @typedef { Object } DateTimeUtility
     * @property { function(Date): string } getTimeString - get's the time string for date as 'hh:mm:ss.fff'
     * @property { function(Date , string, number): Date } setTime - set the time  for date as
     * @property { function(Date): Date } getStartOfNextDay - returns the start of the next day i.e. 00:00:00.000
     * @property { function(Date): Date } getEndOfPreviousDay - returns the 'End' of the previous day i.e. one ms before midnight
     */

    /**
     * 
     * @param {function(Date, number, number, number, number): Date } setTimeForDate - sets a time on a Date object given hh, mm, ss & ms time compononets
     * @param {function(Date): number } getDay 
     * @param {function(Date): number[] } getTimeComponentArray 
     * @param {function} dayInterval - d3-time timeDay or utcDay
     * @param {function} msInterval - d3-time timeMillisecond or utcMillisecond
      * @returns {DateTimeUtility}
     */
    var dateTimeUtility = function dateTimeUtility(setTimeForDate, getDay, getTimeComponentArray, dayInterval, msInterval) {
      var utility = {};

      utility.getTimeComponentArrayFromString = function (timeString) {
        return [timeString.slice(0, 2), timeString.slice(3, 5), timeString.slice(6, 8), timeString.slice(9, 12)];
      };
      /**
          * Returns the local time part of a given Date instance as 'hh:mm:ss.fff'
          * @param {Date} date - Data instance
          * @returns {string} time string.
          */


      utility.getTimeString = function (date) {
        var _getTimeComponentArra = getTimeComponentArray(date).map(function (x) {
          return x.toString(10).padStart(2, '0');
        }),
            _getTimeComponentArra2 = _slicedToArray(_getTimeComponentArra, 4),
            hh = _getTimeComponentArra2[0],
            mm = _getTimeComponentArra2[1],
            ss = _getTimeComponentArra2[2],
            ms = _getTimeComponentArra2[3];

        return "".concat(hh, ":").concat(mm, ":").concat(ss, ".").concat(ms.padStart(3, '0'));
      };
      /**
       * Returns the combined local date and time string
       * @param {Date} date - Data instance
       * @param {string} timeString - string as 'hh:mm:ss.fff'
       * @param {number} offsetInmilliSeconds - additional offset in millisends. Default = 0; e.g. -1 is one millisecond before time specified by timeString;
       * @returns {Date} - combined date and time.
       */


      utility.setTime = function (date, timeString) {
        var offsetInmilliSeconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        var _utility$getTimeCompo = utility.getTimeComponentArrayFromString(timeString),
            _utility$getTimeCompo2 = _slicedToArray(_utility$getTimeCompo, 4),
            hh = _utility$getTimeCompo2[0],
            mm = _utility$getTimeCompo2[1],
            ss = _utility$getTimeCompo2[2],
            ms = _utility$getTimeCompo2[3];

        return msInterval.offset(setTimeForDate(date, hh, mm, ss, ms), offsetInmilliSeconds);
      };
      /**
       * Returns the start of the next day i.e. 00:00:00.000
       * @param {Date} date - Data instance
       * @returns {Date}.
       */


      utility.getStartOfNextDay = function (date) {
        return dayInterval.offset(dayInterval.floor(date), 1);
      };
      /**
       * Returns the end of the previous day (1ms before midnight) i.e.  23:59:59.999
       * @param {Date} date - Data instance
       * @returns {Date}.
       */


      utility.getEndOfPreviousDay = function (date) {
        return msInterval.offset(dayInterval.floor(date), -1);
      };

      utility.dayInterval = dayInterval;
      utility.msInterval = msInterval;
      utility.getDay = getDay;
      return utility;
    };

    var localDateTimeUtility = dateTimeUtility(function (date, hh, mm, ss, ms) {
      return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hh, mm, ss, ms);
    }, function (date) {
      return date.getDay();
    }, function (date) {
      return [date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
    }, d3Time.timeDay, d3Time.timeMillisecond);
    /**
     * Discontinuity provider implemenation that works with 'non-trading' periods during a trading day
     * @typedef { Object } WeeklyPatternDiscontinuityProvider
     * @property { function(Date): Date } clampUp - When given a value, if it falls within a discontinuity (i.e. an excluded domain range) it should be shifted forwards to the discontinuity boundary. Otherwise, it should be returned unchanged.
     * @property { function(Date): Date } clampDown - When given a value, if it falls within a discontinuity it should be shifted backwards to the discontinuity boundary. Otherwise, it should be returned unchanged.
     * @property { function(Date, Date): number } distance - When given a pair of values, this function returns the distance between the, in domain units, minus any discontinuities. discontinuities.
     * @property { function(Date, number): Date } offset - When given a value and an offset, the value should be advanced by the offset value, skipping any discontinuities, to return the final value.
     * @property { function(): WeeklyPatternDiscontinuityProvider } copy - Creates a copy of the discontinuity provider.
      */

    /**
     * Creates WeeklyPatternDiscontinuityProvider
     * @param {Object} nonTradingPattern - contains raw 'non-trading' time ranges for each day of the week
     * @param {DateTimeUtility} dateTimeUtility - uses local or utc dates
     * @returns { WeeklyPatternDiscontinuityProvider } WeeklyPatternDiscontinuityProvider
     */

    var base$1 = function base(nonTradingPattern, dateTimeUtility) {
      var getDayPatternOrDefault = function getDayPatternOrDefault(day) {
        return nonTradingPattern[day] === undefined ? [] : nonTradingPattern[day];
      };

      var tradingDays = [tradingDay(getDayPatternOrDefault('Sunday'), dateTimeUtility), tradingDay(getDayPatternOrDefault('Monday'), dateTimeUtility), tradingDay(getDayPatternOrDefault('Tuesday'), dateTimeUtility), tradingDay(getDayPatternOrDefault('Wednesday'), dateTimeUtility), tradingDay(getDayPatternOrDefault('Thursday'), dateTimeUtility), tradingDay(getDayPatternOrDefault('Friday'), dateTimeUtility), tradingDay(getDayPatternOrDefault('Saturday'), dateTimeUtility)];
      var totalTradingWeekMilliseconds = tradingDays.reduce(function (total, tradingDay) {
        return total + tradingDay.totalTradingTimeInMiliseconds;
      }, 0);

      if (totalTradingWeekMilliseconds === 0) {
        throw 'Trading pattern must yield at least 1 ms of trading time';
      }

      var instance = {
        tradingDays: tradingDays,
        totalTradingWeekMilliseconds: totalTradingWeekMilliseconds
      };
      /**
       * When given a value falls within a discontinuity (i.e. an excluded domain range) it should be shifted forwards to the discontinuity boundary. 
       * Otherwise, it should be returns unchanged.
       * @param {Date} date - date to clamp up
       * @returns {Date}
       */

      instance.clampUp = function (date) {
        var tradingDay = tradingDays[dateTimeUtility.getDay(date)];

        var _iterator = _createForOfIteratorHelper(tradingDay.nonTradingTimeRanges),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var range = _step.value;

            if (range.isInRange(date)) {
              return range.endTime === dayBoundary ? instance.clampUp(dateTimeUtility.getStartOfNextDay(date)) : dateTimeUtility.setTime(date, range.endTime);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return date;
      };
      /** 
       * When given a value, if it falls within a discontinuity it should be shifted backwards to the discontinuity boundary. Otherwise, it should be returned unchanged.
       * @param {Date} date - date to clamp down
       * @returns {Date}
      */


      instance.clampDown = function (date) {
        var tradingDay = tradingDays[dateTimeUtility.getDay(date)];

        var _iterator2 = _createForOfIteratorHelper(tradingDay.nonTradingTimeRanges),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var range = _step2.value;

            if (range.isInRange(date)) {
              return range.startTime === dayBoundary ? instance.clampDown(dateTimeUtility.getEndOfPreviousDay(date)) : dateTimeUtility.setTime(date, range.startTime, -1);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return date;
      };
      /**
       * When given a pair of values, this function returns the distance between the, in domain units, minus any discontinuities. discontinuities.
       * @param {Date} startDate 
       * @param {Date} endDate 
       * @returns {number} - the number of milliseconds between the dates
       */


      instance.distance = function (startDate, endDate) {
        if (startDate.getTime() === endDate.getTime()) {
          return 0;
        }

        var _ref = startDate <= endDate ? [startDate, endDate, 1] : [endDate, startDate, -1],
            _ref2 = _slicedToArray(_ref, 3),
            start = _ref2[0],
            end = _ref2[1],
            factor = _ref2[2]; // same day distance


        if (dateTimeUtility.dayInterval(start).getTime() === dateTimeUtility.dayInterval(end).getTime()) {
          return instance.tradingDays[dateTimeUtility.getDay(start)].totalTradingMillisecondsBetween(start, end);
        } // combine any trading time left in the day after startDate 
        // and any trading time from midnight up until the endDate


        var total = instance.tradingDays[dateTimeUtility.getDay(start)].totalTradingMillisecondsBetween(start, dateTimeUtility.dayInterval.offset(dateTimeUtility.dayInterval(start), 1)) + instance.tradingDays[dateTimeUtility.getDay(end)].totalTradingMillisecondsBetween(dateTimeUtility.dayInterval(end), end); // startDate and endDate are consecutive days    

        if (dateTimeUtility.dayInterval.count(start, end) === 1) {
          return total;
        } // move the start date to following day


        start = dateTimeUtility.dayInterval.offset(dateTimeUtility.dayInterval(start), 1); // floor endDate to remove 'time component'

        end = dateTimeUtility.dayInterval(end);
        return factor * dateTimeUtility.dayInterval.range(start, end).reduce(function (runningTotal, currentDay, currentIndex, arr) {
          var nextDay = currentIndex < arr.length - 1 ? arr[currentIndex + 1] : dateTimeUtility.dayInterval.offset(currentDay, 1);
          var isDstBoundary = nextDay - currentDay !== millisPerDay;
          var tradingDay = instance.tradingDays[dateTimeUtility.getDay(currentDay)];
          return runningTotal += isDstBoundary ? tradingDay.totalTradingMillisecondsBetween(currentDay, nextDay) : tradingDay.totalTradingTimeInMiliseconds;
        }, total);
      };
      /**
       * When given a value and an offset in milliseconds, the value should be advanced by the offset value, skipping any discontinuities, to return the final value.
       * @param {Date} date 
       * @param {number} ms 
       */


      instance.offset = function (date, ms) {
        date = ms >= 0 ? instance.clampUp(date) : instance.clampDown(date);

        var isDstBoundary = function isDstBoundary(d) {
          return dateTimeUtility.dayInterval.offset(d) - dateTimeUtility.dayInterval(d) !== millisPerDay;
        };

        var moveToDayBoundary = function moveToDayBoundary(tradingDay, date, ms) {
          if (ms < 0) {
            var dateFloor = dateTimeUtility.dayInterval(date);
            var distanceToStartOfDay = tradingDay.totalTradingMillisecondsBetween(dateFloor, date);
            return Math.abs(ms) <= distanceToStartOfDay ? tradingDay.offset(date, ms) : [instance.clampDown(dateTimeUtility.msInterval.offset(dateFloor, -1)), ms + distanceToStartOfDay + 1];
          } else {
            var nextDate = dateTimeUtility.getStartOfNextDay(date);
            var distanceToDayBoundary = tradingDay.totalTradingMillisecondsBetween(date, nextDate);
            return ms < distanceToDayBoundary ? tradingDay.offset(date, ms) : [instance.clampUp(nextDate), ms - distanceToDayBoundary];
          }
        };

        if (ms === 0) return date;
        var moveDateDelegate = ms < 0 ? function (date, remainingMs, tradingDayMs) {
          return [instance.clampDown(dateTimeUtility.dayInterval.offset(date, -1)), remainingMs + tradingDayMs];
        } : function (date, remainingMs, tradingDayMs) {
          return [instance.clampUp(dateTimeUtility.dayInterval.offset(date)), remainingMs - tradingDayMs];
        };
        var tradingDay = instance.tradingDays[dateTimeUtility.getDay(date)];

        var _moveToDayBoundary = moveToDayBoundary(tradingDay, date, ms);

        var _moveToDayBoundary2 = _slicedToArray(_moveToDayBoundary, 2);

        date = _moveToDayBoundary2[0];
        ms = _moveToDayBoundary2[1];

        while (ms !== 0) {
          tradingDay = instance.tradingDays[dateTimeUtility.getDay(date)];

          if (isDstBoundary(date)) {
            var _moveToDayBoundary3 = moveToDayBoundary(tradingDay, date, ms);

            var _moveToDayBoundary4 = _slicedToArray(_moveToDayBoundary3, 2);

            date = _moveToDayBoundary4[0];
            ms = _moveToDayBoundary4[1];
          } else {
            var _ref3 = Math.abs(ms) >= tradingDay.totalTradingTimeInMiliseconds ? moveDateDelegate(date, ms, tradingDay.totalTradingTimeInMiliseconds) : moveToDayBoundary(tradingDay, date, ms);

            var _ref4 = _slicedToArray(_ref3, 2);

            date = _ref4[0];
            ms = _ref4[1];
          }
        }

        return date;
      };

      instance.copy = function () {
        return instance;
      };

      return instance;
    };
    var skipWeeklyPattern = (function (nonTradingHoursPattern) {
      return base$1(nonTradingHoursPattern, localDateTimeUtility);
    });

    var utcDateTimeUtility = dateTimeUtility(function (date, hh, mm, ss, ms) {
      return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), hh, mm, ss, ms));
    }, function (date) {
      return date.getUTCDay();
    }, function (date) {
      return [date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()];
    }, d3Time.utcDay, d3Time.utcMillisecond);
    var skipUtcWeeklyPattern = (function (nonTradingUtcHoursPattern) {
      return base$1(nonTradingUtcHoursPattern, utcDateTimeUtility);
    });

    exports.discontinuityIdentity = identity;
    exports.discontinuityRange = provider;
    exports.discontinuitySkipUtcWeekends = skipUtcWeekends;
    exports.discontinuitySkipUtcWeeklyPattern = skipUtcWeeklyPattern;
    exports.discontinuitySkipWeekends = skipWeekends;
    exports.discontinuitySkipWeeklyPattern = skipWeeklyPattern;
    exports.scaleDiscontinuous = discontinuous;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
