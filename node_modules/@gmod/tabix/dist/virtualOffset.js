"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromBytes = void 0;
var VirtualOffset = /** @class */ (function () {
    function VirtualOffset(blockPosition, dataPosition) {
        this.blockPosition = blockPosition; // < offset of the compressed data block
        this.dataPosition = dataPosition; // < offset into the uncompressed data
    }
    VirtualOffset.prototype.toString = function () {
        return "".concat(this.blockPosition, ":").concat(this.dataPosition);
    };
    VirtualOffset.prototype.compareTo = function (b) {
        return (this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition);
    };
    VirtualOffset.min = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var min;
        var i = 0;
        for (; !min; i += 1) {
            min = args[i];
        }
        for (; i < args.length; i += 1) {
            if (min.compareTo(args[i]) > 0) {
                min = args[i];
            }
        }
        return min;
    };
    return VirtualOffset;
}());
exports.default = VirtualOffset;
function fromBytes(bytes, offset, bigendian) {
    if (offset === void 0) { offset = 0; }
    if (bigendian === void 0) { bigendian = false; }
    if (bigendian) {
        throw new Error('big-endian virtual file offsets not implemented');
    }
    return new VirtualOffset(bytes[offset + 7] * 0x10000000000 +
        bytes[offset + 6] * 0x100000000 +
        bytes[offset + 5] * 0x1000000 +
        bytes[offset + 4] * 0x10000 +
        bytes[offset + 3] * 0x100 +
        bytes[offset + 2], (bytes[offset + 1] << 8) | bytes[offset]);
}
exports.fromBytes = fromBytes;
//# sourceMappingURL=virtualOffset.js.map