import AbortablePromiseCache from 'abortable-promise-cache';
import QuickLRU from 'quick-lru';
export default class IndexFile {
    /**
     * @param {filehandle} filehandle
     * @param {function} [renameRefSeqs]
     */
    constructor({ filehandle, renameRefSeqs = (n) => n, }) {
        this.filehandle = filehandle;
        this.renameRefSeq = renameRefSeqs;
    }
    async getMetadata(opts = {}) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { indices, ...rest } = await this.parse(opts);
        return rest;
    }
    _findFirstData(currentFdl, virtualOffset) {
        if (currentFdl) {
            return currentFdl.compareTo(virtualOffset) > 0
                ? virtualOffset
                : currentFdl;
        }
        else {
            return virtualOffset;
        }
    }
    async parse(opts = {}) {
        if (!this._parseCache) {
            this._parseCache = new AbortablePromiseCache({
                cache: new QuickLRU({ maxSize: 1 }),
                fill: () => this._parse(opts),
            });
        }
        return this._parseCache.get('index', null, undefined);
    }
    async hasRefSeq(seqId, opts = {}) {
        return !!((await this.parse(opts)).indices[seqId] || {}).binIndex;
    }
}
//# sourceMappingURL=indexFile.js.map