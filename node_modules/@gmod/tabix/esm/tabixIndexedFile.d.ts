/// <reference types="node" />
import { GenericFilehandle } from 'generic-filehandle';
import { Options } from './indexFile';
import Chunk from './chunk';
declare type GetLinesCallback = (line: string, fileOffset: number) => void;
interface GetLinesOpts {
    [key: string]: unknown;
    signal?: AbortSignal;
    lineCallback: GetLinesCallback;
}
export default class TabixIndexedFile {
    private filehandle;
    private index;
    private chunkSizeLimit;
    private renameRefSeq;
    private chunkCache;
    /**
     * @param {object} args
     * @param {string} [args.path]
     * @param {filehandle} [args.filehandle]
     * @param {string} [args.tbiPath]
     * @param {filehandle} [args.tbiFilehandle]
     * @param {string} [args.csiPath]
     * @param {filehandle} [args.csiFilehandle]
     * @param {chunkSizeLimit} default 50MiB
     * @param {function} [args.renameRefSeqs] optional function with sig `string => string` to transform
     * reference sequence names for the purpose of indexing and querying. note that the data that is returned is
     * not altered, just the names of the reference sequences that are used for querying.
     * @param {number} [args.chunkCacheSize] maximum size in bytes of the chunk cache. default 5MB
     * @param {number} [args.blockCacheSize] maximum size in bytes of the block cache. default 5MB
     */
    constructor({ path, filehandle, tbiPath, tbiFilehandle, csiPath, csiFilehandle, chunkSizeLimit, renameRefSeqs, chunkCacheSize, }: {
        path?: string;
        filehandle?: GenericFilehandle;
        tbiPath?: string;
        tbiFilehandle?: GenericFilehandle;
        csiPath?: string;
        csiFilehandle?: GenericFilehandle;
        chunkSizeLimit?: number;
        renameRefSeqs?: (n: string) => string;
        chunkCacheSize?: number;
    });
    /**
     * @param {string} refName name of the reference sequence
     * @param {number} start start of the region (in 0-based half-open coordinates)
     * @param {number} end end of the region (in 0-based half-open coordinates)
     * @param {function|object} lineCallback callback called for each line in the region. can also pass a object param containing obj.lineCallback, obj.signal, etc
     * @returns {Promise} resolved when the whole read is finished, rejected on error
     */
    getLines(refName: string, start: number, end: number, opts: GetLinesOpts | GetLinesCallback): Promise<void>;
    getMetadata(opts?: Options): Promise<any>;
    /**
     * get a buffer containing the "header" region of
     * the file, which are the bytes up to the first
     * non-meta line
     *
     * @returns {Promise} for a buffer
     */
    getHeaderBuffer(opts?: Options): Promise<Buffer>;
    /**
     * get a string containing the "header" region of the
     * file, is the portion up to the first non-meta line
     *
     * @returns {Promise} for a string
     */
    getHeader(opts?: Options): Promise<string>;
    /**
     * get an array of reference sequence names, in the order in which
     * they occur in the file.
     *
     * reference sequence renaming is not applied to these names.
     *
     * @returns {Promise} for an array of string sequence names
     */
    getReferenceSequenceNames(opts?: Options): Promise<any>;
    /**
     * @param {object} metadata metadata object from the parsed index,
     * containing columnNumbers, metaChar, and format
     * @param {string} regionRefName
     * @param {number} regionStart region start coordinate (0-based-half-open)
     * @param {number} regionEnd region end coordinate (0-based-half-open)
     * @param {array[string]} line
     * @returns {object} like `{startCoordinate, overlaps}`. overlaps is boolean,
     * true if line is a data line that overlaps the given region
     */
    checkLine({ columnNumbers, metaChar, coordinateType, format, }: {
        columnNumbers: {
            ref: number;
            start: number;
            end: number;
        };
        metaChar: string;
        coordinateType: string;
        format: string;
    }, regionRefName: string, regionStart: number, regionEnd: number, line: string): {
        overlaps: boolean;
        startCoordinate?: undefined;
    } | {
        startCoordinate: number;
        overlaps: boolean;
    };
    _getVcfEnd(startCoordinate: number, refSeq: string, info: any): number;
    /**
     * return the approximate number of data lines in the given reference sequence
     * @param {string} refSeq reference sequence name
     * @returns {Promise} for number of data lines present on that reference sequence
     */
    lineCount(refName: string, opts?: Options): Promise<number>;
    _readRegion(position: number, compressedSize: number, opts?: Options): Promise<Buffer>;
    /**
     * read and uncompress the data in a chunk (composed of one or more
     * contiguous bgzip blocks) of the file
     * @param {Chunk} chunk
     * @returns {Promise} for a string chunk of the file
     */
    readChunk(chunk: Chunk, opts?: Options): Promise<any>;
}
export {};
