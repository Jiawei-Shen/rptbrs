"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BBI = void 0;
var binary_parser_1 = require("@gmod/binary-parser");
var generic_filehandle_1 = require("generic-filehandle");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var abortable_promise_cache_1 = __importDefault(require("abortable-promise-cache"));
var quick_lru_1 = __importDefault(require("quick-lru"));
var blockView_1 = require("./blockView");
var BIG_WIG_MAGIC = -2003829722;
var BIG_BED_MAGIC = -2021002517;
/* get the compiled parsers for different sections of the bigwig file
 *
 * @param isBE - is big endian, typically false
 * @return an object with compiled parsers
 */
function getParsers(isBE) {
    var le = isBE ? 'big' : 'little';
    var headerParser = new binary_parser_1.Parser()
        .endianess(le)
        .int32('magic')
        .uint16('version')
        .uint16('numZoomLevels')
        .uint64('chromTreeOffset')
        .uint64('unzoomedDataOffset')
        .uint64('unzoomedIndexOffset')
        .uint16('fieldCount')
        .uint16('definedFieldCount')
        .uint64('asOffset') // autoSql offset, used in bigbed
        .uint64('totalSummaryOffset')
        .uint32('uncompressBufSize')
        .uint64('extHeaderOffset') // name index offset, used in bigbed
        .array('zoomLevels', {
        length: 'numZoomLevels',
        type: new binary_parser_1.Parser()
            .uint32('reductionLevel')
            .uint32('reserved')
            .uint64('dataOffset')
            .uint64('indexOffset'),
    });
    var totalSummaryParser = new binary_parser_1.Parser()
        .endianess(le)
        .uint64('basesCovered')
        .double('scoreMin')
        .double('scoreMax')
        .double('scoreSum')
        .double('scoreSumSquares');
    var chromTreeParser = new binary_parser_1.Parser()
        .endianess(le)
        .uint32('magic')
        .uint32('blockSize')
        .uint32('keySize')
        .uint32('valSize')
        .uint64('itemCount');
    var isLeafNode = new binary_parser_1.Parser()
        .endianess(le)
        .uint8('isLeafNode')
        .skip(1)
        .uint16('cnt');
    return {
        chromTreeParser: chromTreeParser,
        totalSummaryParser: totalSummaryParser,
        headerParser: headerParser,
        isLeafNode: isLeafNode,
    };
}
var BBI = /** @class */ (function () {
    /*
     * @param filehandle - a filehandle from generic-filehandle or implementing something similar to the node10 fs.promises API
     * @param path - a Local file path as a string
     * @param url - a URL string
     * @param renameRefSeqs - an optional method to rename the internal reference sequences using a mapping function
     */
    function BBI(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.headerCache = new abortable_promise_cache_1.default({
            cache: new quick_lru_1.default({ maxSize: 1 }),
            fill: function (params, signal) { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this._getHeader(__assign(__assign({}, params), { signal: signal }))];
                });
            }); },
        });
        var filehandle = options.filehandle, renameRefSeqs = options.renameRefSeqs, path = options.path, url = options.url;
        this.renameRefSeqs = renameRefSeqs || (function (s) { return s; });
        if (filehandle) {
            this.bbi = filehandle;
        }
        else if (url) {
            this.bbi = new generic_filehandle_1.RemoteFile(url);
        }
        else if (path) {
            this.bbi = new generic_filehandle_1.LocalFile(path);
        }
        else {
            throw new Error('no file given');
        }
    }
    /* fetch and parse header information from a bigwig or bigbed file
     * @param abortSignal - abort the operation, can be null
     * @return a Header object
     */
    BBI.prototype.getHeader = function (opts) {
        if (opts === void 0) { opts = {}; }
        var options = 'aborted' in opts ? { signal: opts } : opts;
        return this.headerCache.get(JSON.stringify(options), options, options.signal);
    };
    BBI.prototype._getHeader = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            var header, chroms;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getMainHeader(opts)];
                    case 1:
                        header = _a.sent();
                        return [4 /*yield*/, this._readChromTree(header, opts)];
                    case 2:
                        chroms = _a.sent();
                        return [2 /*return*/, __assign(__assign({}, header), chroms)];
                }
            });
        });
    };
    BBI.prototype._getMainHeader = function (opts, requestSize) {
        if (requestSize === void 0) { requestSize = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var buffer, isBigEndian, ret, header, tail;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.bbi.read(Buffer.alloc(requestSize), 0, requestSize, 0, opts)];
                    case 1:
                        buffer = (_a.sent()).buffer;
                        isBigEndian = this._isBigEndian(buffer);
                        ret = getParsers(isBigEndian);
                        header = ret.headerParser.parse(buffer).result;
                        header.fileType = header.magic === BIG_BED_MAGIC ? 'bigbed' : 'bigwig';
                        if (header.asOffset > requestSize ||
                            header.totalSummaryOffset > requestSize) {
                            return [2 /*return*/, this._getMainHeader(opts, requestSize * 2)];
                        }
                        if (header.asOffset) {
                            header.autoSql = buffer
                                .slice(header.asOffset, buffer.indexOf(0, header.asOffset))
                                .toString('utf8');
                        }
                        if (header.totalSummaryOffset > requestSize) {
                            return [2 /*return*/, this._getMainHeader(opts, requestSize * 2)];
                        }
                        if (header.totalSummaryOffset) {
                            tail = buffer.slice(header.totalSummaryOffset);
                            header.totalSummary = ret.totalSummaryParser.parse(tail).result;
                        }
                        return [2 /*return*/, __assign(__assign({}, header), { isBigEndian: isBigEndian })];
                }
            });
        });
    };
    BBI.prototype._isBigEndian = function (buffer) {
        var ret = buffer.readInt32LE(0);
        if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {
            return false;
        }
        ret = buffer.readInt32BE(0);
        if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {
            return true;
        }
        throw new Error('not a BigWig/BigBed file');
    };
    // todo: add progress if long running
    BBI.prototype._readChromTree = function (header, opts) {
        return __awaiter(this, void 0, void 0, function () {
            var isBE, le, refsByNumber, refsByName, chromTreeOffset, unzoomedDataOffset, data, p, keySize, leafNodeParser, nonleafNodeParser, rootNodeOffset, bptReadNode;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isBE = header.isBigEndian;
                        le = isBE ? 'big' : 'little';
                        refsByNumber = [];
                        refsByName = {};
                        chromTreeOffset = header.chromTreeOffset;
                        unzoomedDataOffset = header.unzoomedDataOffset;
                        while (unzoomedDataOffset % 4 !== 0) {
                            unzoomedDataOffset += 1;
                        }
                        return [4 /*yield*/, this.bbi.read(Buffer.alloc(unzoomedDataOffset - chromTreeOffset), 0, unzoomedDataOffset - chromTreeOffset, chromTreeOffset, opts)];
                    case 1:
                        data = (_a.sent()).buffer;
                        p = getParsers(isBE);
                        keySize = p.chromTreeParser.parse(data).result.keySize;
                        leafNodeParser = new binary_parser_1.Parser()
                            .endianess(le)
                            .string('key', { stripNull: true, length: keySize })
                            .uint32('refId')
                            .uint32('refSize');
                        nonleafNodeParser = new binary_parser_1.Parser()
                            .endianess(le)
                            .skip(keySize)
                            .uint64('childOffset');
                        rootNodeOffset = 32;
                        bptReadNode = function (currentOffset) { return __awaiter(_this, void 0, void 0, function () {
                            var offset, ret, _a, isLeafNode, cnt, n, leafRet, _b, key, refId, refSize, refRec, nextNodes, n, nonleafRet, childOffset;
                            return __generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        offset = currentOffset;
                                        if (offset >= data.length) {
                                            throw new Error('reading beyond end of buffer');
                                        }
                                        ret = p.isLeafNode.parse(data.slice(offset));
                                        _a = ret.result, isLeafNode = _a.isLeafNode, cnt = _a.cnt;
                                        offset += ret.offset;
                                        if (!isLeafNode) return [3 /*break*/, 1];
                                        for (n = 0; n < cnt; n += 1) {
                                            leafRet = leafNodeParser.parse(data.slice(offset));
                                            offset += leafRet.offset;
                                            _b = leafRet.result, key = _b.key, refId = _b.refId, refSize = _b.refSize;
                                            refRec = { name: key, id: refId, length: refSize };
                                            refsByName[this.renameRefSeqs(key)] = refId;
                                            refsByNumber[refId] = refRec;
                                        }
                                        return [3 /*break*/, 3];
                                    case 1:
                                        nextNodes = [];
                                        for (n = 0; n < cnt; n += 1) {
                                            nonleafRet = nonleafNodeParser.parse(data.slice(offset));
                                            childOffset = nonleafRet.result.childOffset;
                                            offset += nonleafRet.offset;
                                            childOffset -= chromTreeOffset;
                                            nextNodes.push(bptReadNode(childOffset));
                                        }
                                        return [4 /*yield*/, Promise.all(nextNodes)];
                                    case 2:
                                        _c.sent();
                                        _c.label = 3;
                                    case 3: return [2 /*return*/];
                                }
                            });
                        }); };
                        return [4 /*yield*/, bptReadNode(rootNodeOffset)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, {
                                refsByName: refsByName,
                                refsByNumber: refsByNumber,
                            }];
                }
            });
        });
    };
    /*
     * fetches the "unzoomed" view of the bigwig data. this is the default for bigbed
     * @param abortSignal - a signal to optionally abort this operation
     */
    BBI.prototype.getUnzoomedView = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, unzoomedIndexOffset, zoomLevels, refsByName, uncompressBufSize, isBigEndian, fileType, nzl, cirLen;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getHeader(opts)];
                    case 1:
                        _a = _b.sent(), unzoomedIndexOffset = _a.unzoomedIndexOffset, zoomLevels = _a.zoomLevels, refsByName = _a.refsByName, uncompressBufSize = _a.uncompressBufSize, isBigEndian = _a.isBigEndian, fileType = _a.fileType;
                        nzl = zoomLevels[0];
                        cirLen = nzl ? nzl.dataOffset - unzoomedIndexOffset : 4000;
                        return [2 /*return*/, new blockView_1.BlockView(this.bbi, refsByName, unzoomedIndexOffset, cirLen, isBigEndian, uncompressBufSize > 0, fileType)];
                }
            });
        });
    };
    /**
     * Gets features from a BigWig file
     *
     * @param refName - The chromosome name
     * @param start - The start of a region
     * @param end - The end of a region
     * @param opts - An object containing basesPerSpan (e.g. pixels per basepair) or scale used to infer the zoomLevel to use
     */
    BBI.prototype.getFeatureStream = function (refName, start, end, opts) {
        if (opts === void 0) { opts = {
            scale: 1,
        }; }
        return __awaiter(this, void 0, void 0, function () {
            var chrName, view;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getHeader(opts)];
                    case 1:
                        _a.sent();
                        chrName = this.renameRefSeqs(refName);
                        if (!opts.basesPerSpan) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getView(1 / opts.basesPerSpan, opts)];
                    case 2:
                        view = _a.sent();
                        return [3 /*break*/, 7];
                    case 3:
                        if (!opts.scale) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.getView(opts.scale, opts)];
                    case 4:
                        view = _a.sent();
                        return [3 /*break*/, 7];
                    case 5: return [4 /*yield*/, this.getView(1, opts)];
                    case 6:
                        view = _a.sent();
                        _a.label = 7;
                    case 7:
                        if (!view) {
                            throw new Error('unable to get block view for data');
                        }
                        return [2 /*return*/, new rxjs_1.Observable(function (observer) {
                                view.readWigData(chrName, start, end, observer, opts);
                            })];
                }
            });
        });
    };
    BBI.prototype.getFeatures = function (refName, start, end, opts) {
        if (opts === void 0) { opts = {
            scale: 1,
        }; }
        return __awaiter(this, void 0, void 0, function () {
            var ob, ret;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getFeatureStream(refName, start, end, opts)];
                    case 1:
                        ob = _a.sent();
                        return [4 /*yield*/, ob
                                .pipe((0, operators_1.reduce)(function (acc, curr) { return acc.concat(curr); }))
                                .toPromise()];
                    case 2:
                        ret = _a.sent();
                        return [2 /*return*/, ret || []];
                }
            });
        });
    };
    return BBI;
}());
exports.BBI = BBI;
//# sourceMappingURL=bbi.js.map