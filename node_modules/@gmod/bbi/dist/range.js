"use strict";
/* eslint prefer-rest-params:0, no-nested-ternary:0 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Adapted from a combination of Range and _Compound in the
 * Dalliance Genome Explorer, (c) Thomas Down 2006-2010.
 */
var Range = /** @class */ (function () {
    function Range(arg1, arg2) {
        this.ranges =
            arguments.length === 2
                ? [{ min: arg1, max: arg2 }]
                : 0 in arg1
                    ? Object.assign({}, arg1)
                    : [arg1];
    }
    Range.prototype.min = function () {
        return this.ranges[0].min;
    };
    Range.prototype.max = function () {
        return this.ranges[this.ranges.length - 1].max;
    };
    Range.prototype.contains = function (pos) {
        for (var s = 0; s < this.ranges.length; s += 1) {
            var r = this.ranges[s];
            if (r.min <= pos && r.max >= pos) {
                return true;
            }
        }
        return false;
    };
    Range.prototype.isContiguous = function () {
        return this.ranges.length > 1;
    };
    Range.prototype.getRanges = function () {
        return this.ranges.map(function (r) { return new Range(r.min, r.max); });
    };
    Range.prototype.toString = function () {
        return this.ranges.map(function (r) { return "[".concat(r.min, "-").concat(r.max, "]"); }).join(',');
    };
    Range.prototype.union = function (s1) {
        var ranges = this.getRanges().concat(s1.getRanges()).sort(this.rangeOrder);
        var oranges = [];
        var current = ranges[0];
        for (var i = 1; i < ranges.length; i += 1) {
            var nxt = ranges[i];
            if (nxt.min() > current.max() + 1) {
                oranges.push(current);
                current = nxt;
            }
            else if (nxt.max() > current.max()) {
                current = new Range(current.min(), nxt.max());
            }
        }
        oranges.push(current);
        if (oranges.length === 1) {
            return oranges[0];
        }
        return new Range(oranges);
    };
    Range.prototype.intersection = function (arg) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var s0 = this;
        var s1 = arg;
        var r0 = this.ranges();
        var r1 = s1.ranges();
        var l0 = r0.length;
        var l1 = r1.length;
        var i0 = 0;
        var i1 = 0;
        var or = [];
        while (i0 < l0 && i1 < l1) {
            s0 = r0[i0];
            s1 = r1[i1];
            var lapMin = Math.max(s0.min(), s1.min());
            var lapMax = Math.min(s0.max(), s1.max());
            if (lapMax >= lapMin) {
                or.push(new Range(lapMin, lapMax));
            }
            if (s0.max() > s1.max()) {
                i1 += 1;
            }
            else {
                i0 += 1;
            }
        }
        if (or.length === 0) {
            throw new Error('found range of length 0');
        }
        if (or.length === 1) {
            return or[0];
        }
        return new Range(or);
    };
    Range.prototype.coverage = function () {
        var tot = 0;
        var rl = this.ranges();
        for (var ri = 0; ri < rl.length; ri += 1) {
            var r = rl[ri];
            tot += r.max() - r.min() + 1;
        }
        return tot;
    };
    Range.prototype.rangeOrder = function (tmpa, tmpb) {
        var a = tmpa;
        var b = tmpb;
        if (arguments.length < 2) {
            b = a;
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            a = this;
        }
        if (a.min() < b.min()) {
            return -1;
        }
        if (a.min() > b.min()) {
            return 1;
        }
        if (a.max() < b.max()) {
            return -1;
        }
        if (b.max() > a.max()) {
            return 1;
        }
        return 0;
    };
    return Range;
}());
exports.default = Range;
//# sourceMappingURL=range.js.map